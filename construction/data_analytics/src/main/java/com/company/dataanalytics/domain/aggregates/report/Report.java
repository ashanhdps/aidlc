package com.company.dataanalytics.domain.aggregates.report;

import com.company.dataanalytics.domain.events.ReportGenerated;
import com.company.dataanalytics.domain.events.ReportGenerationFailed;
import com.company.dataanalytics.domain.shared.AggregateRoot;
import com.company.dataanalytics.domain.valueobjects.*;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

/**
 * Aggregate root for report management
 */
public class Report extends AggregateRoot<ReportId> {
    
    private final TemplateId templateId;
    private final String reportName;
    private final ReportFormat reportFormat;
    private GenerationStatus generationStatus;
    private String filePath;
    private final UserId generatedBy;
    private final Instant generationTimestamp;
    private final Map<String, Object> parameters;
    private String errorMessage;
    private Instant completedTimestamp;
    
    public Report(ReportId id, TemplateId templateId, String reportName, ReportFormat reportFormat,
                 UserId generatedBy, Map<String, Object> parameters) {
        super(id);
        if (reportName == null || reportName.trim().isEmpty()) {
            throw new IllegalArgumentException("Report name cannot be null or empty");
        }
        if (reportFormat == null) {
            throw new IllegalArgumentException("Report format cannot be null");
        }
        if (generatedBy == null) {
            throw new IllegalArgumentException("Generated by cannot be null");
        }
        
        this.templateId = templateId;
        this.reportName = reportName.trim();
        this.reportFormat = reportFormat;
        this.generatedBy = generatedBy;
        this.generationTimestamp = Instant.now();
        this.parameters = new HashMap<>(parameters != null ? parameters : new HashMap<>());
        this.generationStatus = GenerationStatus.PENDING;
    }
    
    public static Report create(TemplateId templateId, String reportName, ReportFormat reportFormat,
                              UserId generatedBy, Map<String, Object> parameters) {
        return new Report(ReportId.generate(), templateId, reportName, reportFormat, generatedBy, parameters);
    }
    
    public static Report create(String reportName, ReportFormat reportFormat, UserId generatedBy) {
        return new Report(ReportId.generate(), null, reportName, reportFormat, generatedBy, null);
    }
    
    public void startGeneration() {
        if (!generationStatus.isPending()) {
            throw new IllegalStateException("Report generation can only be started from PENDING status");
        }
        this.generationStatus = GenerationStatus.IN_PROGRESS;
    }
    
    public void completeGeneration(String filePath) {
        if (!generationStatus.isInProgress()) {
            throw new IllegalStateException("Report generation can only be completed from IN_PROGRESS status");
        }
        if (filePath == null || filePath.trim().isEmpty()) {
            throw new IllegalArgumentException("File path cannot be null or empty");
        }
        
        this.generationStatus = GenerationStatus.COMPLETED;
        this.filePath = filePath.trim();
        this.completedTimestamp = Instant.now();
        this.errorMessage = null;
        
        addDomainEvent(new ReportGenerated(getId(), reportName, reportFormat, generatedBy));
    }
    
    public void failGeneration(String errorMessage) {
        if (!generationStatus.isInProgress()) {
            throw new IllegalStateException("Report generation can only be failed from IN_PROGRESS status");
        }
        
        this.generationStatus = GenerationStatus.FAILED;
        this.errorMessage = errorMessage;
        this.completedTimestamp = Instant.now();
        
        addDomainEvent(new ReportGenerationFailed(getId(), reportName, errorMessage, generatedBy));
    }
    
    public void cancelGeneration() {
        if (generationStatus.isFinished()) {
            throw new IllegalStateException("Cannot cancel a finished report generation");
        }
        
        this.generationStatus = GenerationStatus.CANCELLED;
        this.completedTimestamp = Instant.now();
    }
    
    public boolean isAvailableForDownload() {
        return generationStatus.isCompleted() && filePath != null && !filePath.isEmpty();
    }
    
    public String generateFileName() {
        String sanitizedName = reportName.replaceAll("[^a-zA-Z0-9\\-_]", "_");
        String timestamp = String.valueOf(generationTimestamp.getEpochSecond());
        return String.format("%s_%s%s", sanitizedName, timestamp, reportFormat.getFileExtension());
    }
    
    // Getters
    public TemplateId getTemplateId() {
        return templateId;
    }
    
    public String getReportName() {
        return reportName;
    }
    
    public ReportFormat getReportFormat() {
        return reportFormat;
    }
    
    public GenerationStatus getGenerationStatus() {
        return generationStatus;
    }
    
    public String getFilePath() {
        return filePath;
    }
    
    public UserId getGeneratedBy() {
        return generatedBy;
    }
    
    public Instant getGenerationTimestamp() {
        return generationTimestamp;
    }
    
    public Map<String, Object> getParameters() {
        return new HashMap<>(parameters);
    }
    
    public String getErrorMessage() {
        return errorMessage;
    }
    
    public Instant getCompletedTimestamp() {
        return completedTimestamp;
    }
}